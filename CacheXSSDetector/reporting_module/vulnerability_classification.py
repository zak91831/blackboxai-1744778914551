"""
Vulnerability Classification Module

This module provides classification and categorization of detected cache-based XSS
vulnerabilities to assist in reporting and risk assessment.
"""

import logging
from typing import Dict, List, Optional, Set, Tuple
import re
from datetime import datetime
from collections import defaultdict

class VulnerabilityClassifier:
    """
    A class to classify and categorize detected vulnerabilities.
    """
    
    def __init__(self, config):
        """
        Initialize the Vulnerability Classifier.
        
        Args:
            config (dict): Configuration settings for vulnerability classification.
        """
        self.logger = logging.getLogger('cachexssdetector.vulnerability_classifier')
        self.config = config
        
        # Classification categories
        self.categories = {
            'stored_xss': {
                'name': 'Stored XSS',
                'description': 'Cross-site scripting vulnerability where malicious code is stored on the target server',
                'severity': 'high'
            },
            'reflected_xss': {
                'name': 'Reflected XSS',
                'description': 'Cross-site scripting vulnerability where malicious code is reflected back in the response',
                'severity': 'medium'
            },
            'dom_xss': {
                'name': 'DOM-based XSS',
                'description': 'Cross-site scripting vulnerability that occurs in the Document Object Model',
                'severity': 'medium'
            },
            'cache_poisoning': {
                'name': 'Cache Poisoning',
                'description': 'Attack where malicious content is cached and served to multiple users',
                'severity': 'high'
            },
            'cache_deception': {
                'name': 'Cache Deception',
                'description': 'Attack that tricks the cache into storing private content in a public cache',
                'severity': 'high'
            }
        }
        
        # CWE mappings
        self.cwe_mappings = {
            'stored_xss': 'CWE-79',
            'reflected_xss': 'CWE-79',
            'dom_xss': 'CWE-79',
            'cache_poisoning': 'CWE-444',
            'cache_deception': 'CWE-444'
        }
        
        # CVSS base score components
        self.cvss_components = {
            'stored_xss': {
                'attack_vector': 'network',
                'attack_complexity': 'low',
                'privileges_required': 'none',
                'user_interaction': 'required',
                'scope': 'changed',
                'confidentiality': 'low',
                'integrity': 'low',
                'availability': 'none'
            },
            'reflected_xss': {
                'attack_vector': 'network',
                'attack_complexity': 'low',
                'privileges_required': 'none',
                'user_interaction': 'required',
                'scope': 'changed',
                'confidentiality': 'low',
                'integrity': 'low',
                'availability': 'none'
            },
            'dom_xss': {
                'attack_vector': 'network',
                'attack_complexity': 'medium',
                'privileges_required': 'none',
                'user_interaction': 'required',
                'scope': 'changed',
                'confidentiality': 'low',
                'integrity': 'low',
                'availability': 'none'
            },
            'cache_poisoning': {
                'attack_vector': 'network',
                'attack_complexity': 'medium',
                'privileges_required': 'none',
                'user_interaction': 'none',
                'scope': 'changed',
                'confidentiality': 'medium',
                'integrity': 'medium',
                'availability': 'low'
            },
            'cache_deception': {
                'attack_vector': 'network',
                'attack_complexity': 'high',
                'privileges_required': 'none',
                'user_interaction': 'none',
                'scope': 'changed',
                'confidentiality': 'high',
                'integrity': 'none',
                'availability': 'none'
            }
        }
        
        self.logger.info("Vulnerability Classifier initialized")
    
    def classify_vulnerability(
        self,
        finding: Dict,
        context: Optional[Dict] = None
    ) -> Dict:
        """
        Classify a vulnerability finding.
        
        Args:
            finding (dict): Vulnerability finding to classify.
            context (dict, optional): Additional context information.
            
        Returns:
            dict: Classification results.
        """
        classification = {
            'primary_category': None,
            'secondary_categories': [],
            'confidence': 0.0,
            'cwe': None,
            'cvss': None,
            'owasp_top_10': None,
            'description': '',
            'details': {}
        }
        
        try:
            # Determine primary category
            primary = self._determine_primary_category(finding)
            classification['primary_category'] = primary['category']
            classification['confidence'] = primary['confidence']
            
            # Add category details
            if classification['primary_category'] in self.categories:
                category_info = self.categories[classification['primary_category']]
                classification['description'] = category_info['description']
            
            # Determine secondary categories
            classification['secondary_categories'] = self._determine_secondary_categories(
                finding,
                classification['primary_category']
            )
            
            # Map to CWE
            classification['cwe'] = self._map_to_cwe(classification['primary_category'])
            
            # Calculate CVSS score
            classification['cvss'] = self._calculate_cvss(finding, classification['primary_category'])
            
            # Map to OWASP Top 10
            classification['owasp_top_10'] = self._map_to_owasp(classification['primary_category'])
            
            # Generate details
            classification['details'] = self._generate_classification_details(
                finding,
                classification
            )
            
        except Exception as e:
            self.logger.error(f"Error classifying vulnerability: {str(e)}")
        
        return classification
    
    def classify_batch(
        self,
        findings: List[Dict],
        context: Optional[Dict] = None
    ) -> Dict:
        """
        Classify a batch of vulnerability findings.
        
        Args:
            findings (list): List of findings to classify.
            context (dict, optional): Additional context information.
            
        Returns:
            dict: Batch classification results.
        """
        results = {
            'total_findings': len(findings),
            'category_distribution': defaultdict(int),
            'classifications': [],
            'severity_distribution': defaultdict(int),
            'summary': {}
        }
        
        try:
            for finding in findings:
                classification = self.classify_vulnerability(finding, context)
                results['classifications'].append({
                    'finding': finding,
                    'classification': classification
                })
                
                # Update distributions
                if classification['primary_category']:
                    results['category_distribution'][classification['primary_category']] += 1
                    
                    category_info = self.categories.get(classification['primary_category'], {})
                    severity = category_info.get('severity', 'medium')
                    results['severity_distribution'][severity] += 1
            
            # Generate summary
            results['summary'] = self._generate_batch_summary(results)
            
        except Exception as e:
            self.logger.error(f"Error in batch classification: {str(e)}")
        
        return results
    
    def _determine_primary_category(self, finding: Dict) -> Dict:
        """
        Determine the primary vulnerability category.
        
        Args:
            finding (dict): Finding to categorize.
            
        Returns:
            dict: Primary category and confidence.
        """
        result = {
            'category': 'unknown',
            'confidence': 0.0
        }
        
        try:
            # Check for cache-specific indicators
            cache_info = finding.get('cache_info', {})
            cache_behavior = finding.get('cache_behavior', {})
            
            if cache_info.get('is_cached', False):
                # Check for stored XSS characteristics
                if self._has_persistent_payload(finding):
                    result['category'] = 'cache_poisoning'
                    result['confidence'] = 0.9
                # Check for cache deception characteristics
                elif self._has_cache_deception_characteristics(finding):
                    result['category'] = 'cache_deception'
                    result['confidence'] = 0.8
            else:
                # Check reflected XSS characteristics
                if self._has_reflected_payload(finding):
                    result['category'] = 'reflected_xss'
                    result['confidence'] = 0.9
                # Check DOM XSS characteristics
                elif self._has_dom_xss_characteristics(finding):
                    result['category'] = 'dom_xss'
                    result['confidence'] = 0.8
            
        except Exception as e:
            self.logger.error(f"Error determining primary category: {str(e)}")
        
        return result
    
    def _determine_secondary_categories(
        self,
        finding: Dict,
        primary_category: str
    ) -> List[str]:
        """
        Determine secondary vulnerability categories.
        
        Args:
            finding (dict): Finding to categorize.
            primary_category (str): Primary category.
            
        Returns:
            list: Secondary categories.
        """
        secondary = []
        
        try:
            # Add related categories
            if primary_category == 'cache_poisoning':
                if self._has_dom_xss_characteristics(finding):
                    secondary.append('dom_xss')
                elif self._has_reflected_payload(finding):
                    secondary.append('reflected_xss')
            
        except Exception as e:
            self.logger.error(f"Error determining secondary categories: {str(e)}")
        
        return secondary
    
    def _has_persistent_payload(self, finding: Dict) -> bool:
        """
        Check if finding has persistent payload characteristics.
        
        Args:
            finding (dict): Finding to check.
            
        Returns:
            bool: True if payload appears persistent.
        """
        try:
            cache_info = finding.get('cache_info', {})
            cache_behavior = finding.get('cache_behavior', {})
            
            # Check if payload is stored in cache
            if cache_info.get('is_cached', False):
                # Check cache persistence
                if cache_behavior.get('ttl_estimate', 0) > 60:  # More than 1 minute
                    return True
                
                # Check multiple client affection
                if cache_behavior.get('affected_clients', []):
                    return True
            
            return False
            
        except Exception:
            return False
    
    def _has_reflected_payload(self, finding: Dict) -> bool:
        """
        Check if finding has reflected payload characteristics.
        
        Args:
            finding (dict): Finding to check.
            
        Returns:
            bool: True if payload appears reflected.
        """
        try:
            response = finding.get('response', {})
            payload = finding.get('payload', {})
            
            if not response or not payload:
                return False
            
            # Check if payload content is reflected in response
            payload_content = payload.get('content', '')
            response_content = response.get('content', '')
            
            if payload_content and payload_content in response_content:
                return True
            
            return False
            
        except Exception:
            return False
    
    def _has_dom_xss_characteristics(self, finding: Dict) -> bool:
        """
        Check if finding has DOM XSS characteristics.
        
        Args:
            finding (dict): Finding to check.
            
        Returns:
            bool: True if payload appears to be DOM-based.
        """
        try:
            payload = finding.get('payload', {})
            response = finding.get('response', {})
            
            if not payload or not response:
                return False
            
            # Check for DOM manipulation patterns
            payload_content = payload.get('content', '')
            
            dom_patterns = [
                'document.', 'window.', 'eval(', 'innerHTML',
                'location.', 'history.', 'localStorage'
            ]
            
            for pattern in dom_patterns:
                if pattern in payload_content:
                    return True
            
            return False
            
        except Exception:
            return False
    
    def _has_cache_deception_characteristics(self, finding: Dict) -> bool:
        """
        Check if finding has cache deception characteristics.
        
        Args:
            finding (dict): Finding to check.
            
        Returns:
            bool: True if cache deception is likely.
        """
        try:
            cache_info = finding.get('cache_info', {})
            headers = finding.get('response', {}).get('headers', {})
            
            # Check for sensitive content indicators
            content_type = headers.get('Content-Type', '').lower()
            if 'json' in content_type or 'xml' in content_type:
                # Check for private data in public cache
                if cache_info.get('cache_type', '') == 'public':
                    return True
            
            return False
            
        except Exception:
            return False
    
    def _map_to_cwe(self, category: str) -> str:
        """
        Map vulnerability category to CWE identifier.
        
        Args:
            category (str): Vulnerability category.
            
        Returns:
            str: CWE identifier.
        """
        return self.cwe_mappings.get(category, 'CWE-79')  # Default to XSS
    
    def _calculate_cvss(self, finding: Dict, category: str) -> Dict:
        """
        Calculate CVSS score for vulnerability.
        
        Args:
            finding (dict): Vulnerability finding.
            category (str): Vulnerability category.
            
        Returns:
            dict: CVSS score components.
        """
        cvss = {
            'version': '3.1',
            'base_score': 0.0,
            'vector_string': '',
            'components': {}
        }
        
        try:
            # Get base CVSS components for category
            components = self.cvss_components.get(category, {})
            
            if not components:
                return cvss
            
            # Apply adjustments based on finding details
            adjusted_components = components.copy()
            
            # Adjust attack complexity
            cache_info = finding.get('cache_info', {})
            if cache_info.get('consistency', 0) < 0.5:
                adjusted_components['attack_complexity'] = 'high'
            
            # Adjust impact metrics
            risk_assessment = finding.get('risk_assessment', {})
            if risk_assessment.get('impact_score', 0) > 0.8:
                adjusted_components['confidentiality'] = 'high'
                adjusted_components['integrity'] = 'high'
            
            # Calculate base score (simplified calculation)
            impact_values = {
                'none': 0, 'low': 0.22, 'medium': 0.4, 'high': 0.56
            }
            
            exploit_values = {
                'network': 0.85, 'adjacent': 0.62, 'local': 0.55, 'physical': 0.2
            }
            
            complexity_values = {
                'low': 0.77, 'medium': 0.44, 'high': 0.2
            }
            
            impact = (
                impact_values[adjusted_components.get('confidentiality', 'none')] +
                impact_values[adjusted_components.get('integrity', 'none')] +
                impact_values[adjusted_components.get('availability', 'none')]
            ) / 3
            
            exploitability = (
                exploit_values[adjusted_components.get('attack_vector', 'network')] *
                complexity_values[adjusted_components.get('attack_complexity', 'medium')]
            )
            
            # Simplified CVSS calculation
            cvss['base_score'] = round((impact * 0.6 + exploitability * 0.4) * 10) / 10
            
            # Format vector string
            vector = f"CVSS:3.1/AV:{adjusted_components.get('attack_vector', 'N')[0].upper()}/AC:{adjusted_components.get('attack_complexity', 'L')[0].upper()}"
            cvss['vector_string'] = vector
            
            cvss['components'] = adjusted_components
            
        except Exception as e:
            self.logger.error(f"Error calculating CVSS: {str(e)}")
        
        return cvss
    
    def _map_to_owasp(self, category: str) -> List[str]:
        """
        Map vulnerability to OWASP Top 10 categories.
        
        Args:
            category (str): Vulnerability category.
            
        Returns:
            list: OWASP Top 10 categories.
        """
        owasp_mappings = {
            'stored_xss': ['A3:2021-Injection', 'A7:2017-XSS'],
            'reflected_xss': ['A3:2021-Injection', 'A7:2017-XSS'],
            'dom_xss': ['A3:2021-Injection', 'A7:2017-XSS'],
            'cache_poisoning': ['A5:2021-Security Misconfiguration', 'A6:2017-Security Misconfiguration'],
            'cache_deception': ['A5:2021-Security Misconfiguration', 'A6:2017-Security Misconfiguration']
        }
        
        return owasp_mappings.get(category, ['A3:2021-Injection'])
    
    def _generate_classification_details(
        self,
        finding: Dict,
        classification: Dict
    ) -> Dict:
        """
        Generate detailed classification information.
        
        Args:
            finding (dict): Vulnerability finding.
            classification (dict): Classification results.
            
        Returns:
            dict: Detailed classification information.
        """
        details = {
            'classification_rationale': [],
            'vulnerability_pattern': '',
            'cache_involvement': '',
            'technical_impact': ''
        }
        
        try:
            # Generate rationale
            category = classification['primary_category']
            if category == 'cache_poisoning':
                details['classification_rationale'].append(
                    "Vulnerability allows cache poisoning through persistent malicious content"
                )
                details['cache_involvement'] = "Cache stores and serves malicious content to multiple users"
                details['vulnerability_pattern'] = "Stored XSS via cache"
                details['technical_impact'] = "Multiple users can be affected by a single payload"
            
            elif category == 'reflected_xss':
                details['classification_rationale'].append(
                    "Vulnerability allows reflected XSS through unvalidated input"
                )
                details['cache_involvement'] = "Response not cached, affects single request"
                details['vulnerability_pattern'] = "Reflected XSS"
                details['technical_impact'] = "Attacker can execute arbitrary JavaScript in user context"
            
            elif category == 'dom_xss':
                details['classification_rationale'].append(
                    "Vulnerability exists in client-side JavaScript processing"
                )
                details['cache_involvement'] = "Minimal - vulnerability exists in client-side processing"
                details['vulnerability_pattern'] = "DOM-based XSS"
                details['technical_impact'] = "Attacker can manipulate DOM and execute arbitrary JavaScript"
            
            elif category == 'cache_deception':
                details['classification_rationale'].append(
                    "Vulnerability allows caching of private/sensitive content"
                )
                details['cache_involvement'] = "Cache incorrectly stores private content in public context"
                details['vulnerability_pattern'] = "Path confusion leading to cache deception"
                details['technical_impact'] = "Sensitive information disclosure to unauthorized users"
            
        except Exception as e:
            self.logger.error(f"Error generating classification details: {str(e)}")
        
        return details
    
    def _generate_batch_summary(self, results: Dict) -> Dict:
        """
        Generate summary for batch classification.
        
        Args:
            results (dict): Batch classification results.
            
        Returns:
            dict: Summary information.
        """
        summary = {
            'most_common_category': '',
            'highest_severity': '',
            'key_vulnerabilities': [],
            'overall_assessment': ''
        }
        
        try:
            # Find most common category
            if results['category_distribution']:
                summary['most_common_category'] = max(
                    results['category_distribution'].items(),
                    key=lambda x: x[1]
                )[0]
            
            # Find highest severity
            severity_order = ['critical', 'high', 'medium', 'low', 'info']
            for severity in severity_order:
                if results['severity_distribution'].get(severity, 0) > 0:
                    summary['highest_severity'] = severity
                    break
            
            # Identify key vulnerabilities
            for item in results['classifications']:
                category = item['classification']['primary_category']
                if category in ['cache_poisoning', 'cache_deception']:
                    summary['key_vulnerabilities'].append({
                        'category': category,
                        'description': self.categories.get(category, {}).get('description', ''),
                        'cvss': item['classification']['cvss']['base_score']
                    })
            
            # Generate overall assessment
            if summary['highest_severity'] in ['critical', 'high']:
                summary['overall_assessment'] = (
                    "Critical cache-based vulnerabilities detected. "
                    "Immediate remediation is required."
                )
            elif summary['highest_severity'] == 'medium':
                summary['overall_assessment'] = (
                    "Moderate cache-based vulnerabilities detected. "
                    "Remediation is recommended."
                )
            else:
                summary['overall_assessment'] = (
                    "Low-severity cache-based issues detected. "
                    "Consider addressing as part of regular maintenance."
                )
            
        except Exception as e:
            self.logger.error(f"Error generating batch summary: {str(e)}")
        
        return summary
